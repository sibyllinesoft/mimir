# Deep Code Research System — Vision & Architecture (Concise)

A **full-Python**, **stdio MCP** that indexes local repos, exposes a single clean API to agents, and ships a small **management UI** to observe runs. Heavy logic lives in one pipeline: **Acquire → RepoMapper → Serena → LEANN → Snippets → Bundle**. Agents call **once to index**, get a **notification on stage transitions**, then **search/ask** the finished index. Context7 is a separate MCP used *after* code evidence is assembled.

---

## Goals & Non-Goals

* **Goals:** zero-prompt local indexing; defensible citations; CPU-only; robust to large monorepos; agent-friendly MCP; optional local dashboard.
* **Non-Goals:** web crawling (handled by other agents), global package indexing (`node_modules/` shotgun), GPU dependency, remote services.

---

## Directory Layout (top-level)

```
repoindex/
  pyproject.toml
  uv.lock
  README.md
  docs/
    ARCHITECTURE.md   # this doc
    API.md            # MCP + UI routes (autogenerated from code)
  src/repoindex/
    mcp/
      server.py           # MCP stdio entrypoint (console script)
      tools.py            # tool handlers
      resources.py        # status/manifest/log/bundle resources
      events.py           # stage transition notifications
    pipeline/
      run.py              # orchestrates stages (asyncio)
      discover.py         # git-scoped file discovery & deltas
      repomapper.py       # adapter (in-proc or CLI)
      serena.py           # adapter; tsserver orchestration
      leann.py            # adapter; CPU index build
      snippets.py         # stable byte-span extraction
      bundle.py           # manifest & tar.zst
      hybrid_search.py    # vector+symbol+graph merge
      ask_index.py        # multi-hop symbol Q&A
    data/
      schemas/            # jsonschema for manifest, results
    ui/                   # optional local dashboard (FastAPI + static SPA)
      app.py              # localhost UI server (off by default)
      static/             # built SPA (Cytoscape/Monaco/TanStack Table)
    util/
      gitio.py            # subprocess helpers
      fs.py               # atomic writes, content hashing
      log.py              # events.jsonl writer
  var/
    indexes/              # run state (status.json, manifest.json, bundle.tar.zst, …)
```

---

## MCP Surface (single server, stdio)

**Tools (stable contracts):**

* `ensure_repo_index({ path, rev?, language?="ts", index_opts? }) -> { index_id, status_uri, manifest_uri }`
* `get_repo_bundle({ index_id }) -> { bundle_uri, manifest_uri }`
* `search_repo({ index_id, query, k?, features?={vector:true,symbol:true,graph:true}, context_lines?=5 }) -> { results[], citations[] }`
* `ask_index({ index_id, question, context_lines?=5 }) -> { answer, citations[] }`
* `cancel({ index_id }) -> { ok }`

**Resources (subscribe; stage transitions only):**

* `…/status.json` — `{state, stage, progress, error?}`
* `…/manifest.json` — stable schema (below)
* `…/log.md` — human skim
* `…/bundle.tar.zst` — all artifacts

**State transitions:** `queued → running(acquire → repomapper → serena → leann → snippets → bundle) → done|failed`

---

## Indexing Pipeline (local-first)

**Scope & selection**

* Root: `git rev-parse --show-toplevel`
* Files: `git ls-files -z` filtered by `ts,tsx,js,jsx,md,mdx,json,yaml`
* Exclusions: `node_modules/, dist/, build/, .next/, coverage/`
* Monorepos: detect workspaces and aggregate tracked files.

**Incremental & overlays**

* Index key = `(HEAD tree hash, config hash)`
* Include **dirty overlay** (uncommitted changes) via `git hash-object` per file.

**Stage behaviors**

1. **Acquire**: collect tracked set; compute fingerprints; record HEAD & dirty overlay.
2. **RepoMapper**: Tree-sitter + PageRank → `repomap.json` (`file_rank[]`, `edges[]`).
3. **Serena** (TS/LSP):

   * **First-order dependency types** for the whole project (`.d.ts`).
   * **Actual code** for **direct imports** only (entrypoints + first-order imports resolved via `exports` & sourcemaps).
   * Emit `serena_graph.jsonl`: defs/refs/calls/imports/signatures with **byte spans**.
4. **LEANN** (CPU):

   * Ingest **strictly in RepoMapper order**, then high-centrality & dirty files.
   * Chunks: function-level else \~400 tokens, overlap 64.
   * Output `leann.index` + `vectors.bin`.
5. **Snippets**: extract stable `(path, span, content_sha, pre/text/post)` with ±5 lines (configurable).
6. **Bundle**: write `manifest.json`; tar+zstd all artifacts → `bundle.tar.zst`.

**Citations** everywhere: `{repo_root, rev|worktree, path, span, content_sha}`.

---

## Data Schemas (essentials)

**`manifest.json`**

```json
{
  "index_id": "IDX_ulid",
  "repo": { "root": "/abs/path", "rev": "HEAD_sha", "worktree_dirty": true },
  "config": {
    "languages": ["ts","tsx","js","jsx"],
    "excludes": ["node_modules/","dist/","build/",".next/","coverage/"],
    "context_lines": 5,
    "features": { "vector": true, "symbol": true, "graph": true }
  },
  "counts": { "files_total": 0, "files_indexed": 0, "symbols_defs": 0, "symbols_refs": 0, "vectors": 0 },
  "paths": {
    "repomap": "repomap.json",
    "serena_graph": "serena_graph.jsonl",
    "leann_index": "leann.index",
    "vectors": "vectors.bin",
    "snippets": "snippets.jsonl",
    "vendor_types": "types/",
    "vendor_sources": "vendor_src/",
    "bundle": "bundle.tar.zst"
  },
  "versions": { "repomapper": "x.y", "serena": "x.y", "leann": "x.y", "tsserver": "x.y" }
}
```

**`serena_graph.jsonl` (per line)**

```json
{"type":"def","symbol":"Foo.bar","path":"src/foo.ts","span":[210,278],"sig":"(x:T)=>U"}
{"type":"ref","symbol":"Foo.bar","path":"src/app.ts","span":[301,309]}
{"type":"call","caller":"A.baz","callee":"Foo.bar","path":"src/app.ts","span":[...]}
{"type":"import","from":"react","path":"src/app.ts","span":[5,17]}
```

**`snippets.jsonl`**

```json
{"path":"src/foo.ts","span":[210,278],"hash":"sha256:…","pre":"…","text":"function bar(x:T){…}","post":"…"}
```

---

## Core Algorithms (pseudocode)

**ensure\_repo\_index → pipeline**

```python
async def ensure_repo_index(path, rev=None):
    idx = new_ulid(); base = mkstate(idx)
    write_status(idx, "running", "acquire", 1)

    async def run():
        top, head, files = discover_git(path)
        stage("repomapper", 5); repomap = await run_repomapper(top, files, base)
        stage("serena", 25);    sgraph  = await run_serena(top, files, base,
                               types_for_first_order=True, code_for_direct_imports=True)
        stage("leann", 55);     ann     = await build_leann(top, repomap, sgraph, base)
        stage("snippets", 80);  snips   = await extract_snippets(top, sgraph, base, ctx=5)
        mani = write_manifest(base, top, head, repomap, sgraph, ann, snips)
        bundle = make_bundle(base, mani["paths"]["bundle"])
        stage("bundle", 100, done=True)
    asyncio.create_task(run())
    return { "index_id": idx, "status_uri": status_uri(idx), "manifest_uri": manifest_uri(idx) }
```

**Hybrid search (no reranker yet)**

```python
def hybrid_search(idx, query, k=20, features={"vector":True,"symbol":True,"graph":True}, ctx=5):
    cand = []
    if features["vector"]:
        cand += leann_topk(idx, query, k=4*k)
    if features["symbol"]:
        cand += serena_symbol_hits(idx, query)      # name/sig/xref
    if features["graph"]:
        cand = expand_with_graph_prior(idx, cand)   # neighbors via RepoMapper

    merged = dedupe_by_span(cand)
    for r in merged:
        r.score = 1.0*r.vec + 0.9*r.sym + 0.3*r.graph
        r.pre, r.text, r.post = load_snippet(idx, r.path, r.span, ctx)
    return topk(merged, k)
```

**ask\_index (multi-hop over symbol graph)**

```python
def ask_index(idx, question, ctx=5):
    intents = parse_intent(question)  # symbol, file, import, callgraph
    seeds = plan_symbols(idx, intents)
    hops = walk_callgraph(idx, seeds, max_depth=2)
    evidence = gather_snippets(idx, hops, ctx)
    answer = template_summarize(evidence)  # no LLM synthesis by default
    return { "answer": answer, "citations": [e.citation for e in evidence] }
```

**Types & vendor source policy**

```python
def resolve_imports(project):
    for pkg in first_order_dependencies(project):
        install_types(pkg)                      # .d.ts globally for project
    for imp in direct_imports_in_code(project):
        add_vendor_source(entrypoint_of(imp))   # bundle entry + its first-order deps
```

---

## Management UI (optional, local-only)

**Purpose:** observe runs; inspect graph; drill into snippets; run ad-hoc queries; prep collections for the code agent.

**Views (brief):**

* **Run Overview:** stage tiles, metrics, events.
* **Task Graph:** lanes per stage; nodes = batch tasks; replay scrubber; right-drawer inspector.
* **Coverage & Evidence:** file heatmap + Monaco snippet viewer; hybrid score breakdown; copy-ready citations.
* **Search Console:** query/result notebook; save “collections.”
* **Library Docs Pane:** suggest Context7 targets from Serena imports; fetch versioned sections; stitch with snippets.
* **Run Compare:** HEAD vs prior run deltas.

**Backend (UI server; off by default)**

* FastAPI on `127.0.0.1:<port>`, SSE `/events` (rebroadcast stage transitions), REST for `status.json`, `manifest.json`, `graph.json`, `coverage.jsonl`, `search_repo`, `ask_index`.
* Static SPA (Cytoscape graph, Monaco code, TanStack Table).
* No external ingress, no telemetry, optional redaction.

---

## Operational Notes

* **CPU-only**; concurrency defaults: IO=8, CPU=2 (env-tunable).
* **Bundles**: warn >1.5 GB, shard at 2 GB.
* **Notifications**: only at stage boundaries (matches agent expectations; reduces host churn).
* **Caching**: content-hash everything; skip unchanged across runs; overlay uncommitted diffs.
* **Failure policy**: continue with partials when safe; mark gaps in `manifest.json`; surface in UI.

---

## Context7 Integration (separate MCP)

After `search_repo`, collect top **symbols & imports** → query Context7 for **versioned docs** of those libs → present alongside snippets in UI → pass both to the code-analysis agent for synthesis (your toggles: *extract only* vs *synthesis allowed*).

---

## Configuration (knobs that matter)

* `features.vector|symbol|graph` (enable/disable)
* `context_lines` (default 5)
* `max_files_to_embed` (RepoMapper-ordered; always include dirty files)
* `imports_policy` (`types_for_first_order=True`, `code_for_direct_imports=True`)
* `watch_mode` (fsnotify with debounce)

---

## Deliverables Checklist (for implementation)

* MCP stdio server with five tools and four resources.
* Pipeline stages with stage-transition events only.
* Git-scoped discovery + incremental overlays.
* Adapters for RepoMapper, Serena(+tsserver), LEANN (CPU).
* Hybrid search + ask\_index (no ML reranker).
* Manifest & schemas; deterministic bundle writer.
* Optional local UI server + SPA with Overview, Graph, Coverage/Evidence, Search, Compare.
* Docs: this file, `API.md` (autogen), quickstart.

That’s the spine. It’s small enough to stay understandable, rich enough to let an agent run for hours without ambiguity, and strict about provenance so reports are easy to defend.
